"""ICC profile utilities.

This module contains helpers to create or save ICC profiles.
It implements a basic binary ICC v2.4 writer to generate a valid
Matrix/TRC profile based on measured primaries.
"""
import struct
import datetime
import numpy as np
import pandas as pd
import colour


def build_and_export_icc(
    measurements_df: pd.DataFrame, 
    reference_labs: dict, 
    filename: str
) -> tuple[bool, str]:
    """
    Builds a valid binary ICC profile and exports it to a file.

    Generates a 'prtr' (Printer) class profile using a Matrix/TRC model
    derived from the measured R, G, B, and White patches.

    Parameters
    ----------
    measurements_df : pd.DataFrame
        DataFrame containing the measured patch data, including 'patch', 'L', 'a', 'b'.
    reference_labs : dict
        Dictionary of reference Lab values with patch names as keys.
    filename : str
        The path to save the placeholder ICC profile to.

    Returns
    -------
    tuple[bool, str]
        A tuple containing a boolean success status and a message.
    """
    if not filename.lower().endswith(".icc"):
        filename += ".icc"

    try:
        # 1. Extract Primaries from measurements
        # We need R (255,0,0), G (0,255,0), B (0,0,255) to build the matrix.
        # Assuming patch names "R", "G", "B" exist in the dataframe.
        primaries = {}
        for name in ["R", "G", "B"]:
            row = measurements_df[measurements_df["patch"] == name]
            if row.empty:
                return False, f"Missing required patch '{name}' for ICC generation."
            
            # Get Lab and convert to XYZ (D50)
            # Note: colour.Lab_to_XYZ returns XYZ scaled 0..1 (usually) or 0..100 depending on setup.
            # ICC requires XYZ encoded as s15Fixed16Number (approx 0..1 range usually mapped).
            # colour default is 0..1 for XYZ if Lab is 0..100.
            L, a, b = row.iloc[0][["L", "a", "b"]]
            XYZ = colour.Lab_to_XYZ([L, a, b]) # Uses D50 by default in recent colour versions for Lab
            primaries[name] = XYZ

        # 2. Prepare Tags
        # D50 standard illuminant for PCS
        D50_XYZ = [0.9642, 1.0000, 0.8249]

        tags = []

        # desc: Profile Description
        desc_str = "Printer Calibration Profile"
        tags.append(('desc', _create_text_description_type(desc_str)))

        # cprt: Copyright
        cprt_str = "Generated by Printer Calibration GUI"
        tags.append(('cprt', _create_text_type(cprt_str)))

        # wtpt: Media White Point (Required)
        tags.append(('wtpt', _create_xyz_type(D50_XYZ)))

        # rXYZ, gXYZ, bXYZ: Matrix columns
        tags.append(('rXYZ', _create_xyz_type(primaries["R"])))
        tags.append(('gXYZ', _create_xyz_type(primaries["G"])))
        tags.append(('bXYZ', _create_xyz_type(primaries["B"])))

        # rTRC, gTRC, bTRC: Tone Reproduction Curves
        # Using a standard Gamma 2.2 curve for validity
        gamma_tag = _create_curve_type(2.2)
        tags.append(('rTRC', gamma_tag))
        tags.append(('gTRC', gamma_tag))
        tags.append(('bTRC', gamma_tag))

        # 3. Serialize
        # Calculate offsets
        header_size = 128
        tag_count = len(tags)
        tag_table_size = 4 + (12 * tag_count)
        
        current_offset = header_size + tag_table_size
        tag_table_data = bytearray()
        tag_data_block = bytearray()

        # Sort tags by signature as per spec (recommended)
        tags.sort(key=lambda x: x[0])

        tag_table_data.extend(struct.pack('>I', tag_count))

        for sig, data in tags:
            size = len(data)
            # Signature, Offset, Size
            tag_table_data.extend(sig.encode('ascii'))
            tag_table_data.extend(struct.pack('>II', current_offset, size))
            
            tag_data_block.extend(data)
            
            # Align to 4-byte boundary
            padding = (4 - (size % 4)) % 4
            tag_data_block.extend(b'\x00' * padding)
            current_offset += size + padding

        total_size = header_size + tag_table_size + len(tag_data_block)

        # 4. Write Header
        # Size, CMM, Version(2.4), Class(prtr), Space(RGB), PCS(XYZ), Date...
        header = bytearray(128)
        struct.pack_into('>I', header, 0, total_size)
        struct.pack_into('>4s', header, 4, b'py  ') # CMM ID
        struct.pack_into('>I', header, 8, 0x02400000) # Version 2.4.0
        struct.pack_into('>4s', header, 12, b'prtr') # Class: Printer
        struct.pack_into('>4s', header, 16, b'RGB ') # Data Colour Space
        struct.pack_into('>4s', header, 20, b'XYZ ') # PCS
        
        now = datetime.datetime.now()
        struct.pack_into('>HHHHHH', header, 24, 
                         now.year, now.month, now.day, 
                         now.hour, now.minute, now.second)
        
        struct.pack_into('>4s', header, 36, b'acsp') # Signature
        struct.pack_into('>I', header, 64, 1) # Rendering Intent: Perceptual
        struct.pack_into('>III', header, 68, 0x0000F6D6, 0x00010000, 0x0000D32D) # D50 XYZ

        # Write to file
        with open(filename, "wb") as f:
            f.write(header)
            f.write(tag_table_data)
            f.write(tag_data_block)

        return True, f"Successfully exported valid ICC profile to {filename}"

    except Exception as e:
        return False, f"Failed to export ICC profile: {e}"


def _create_xyz_type(xyz):
    """Creates an XYZType tag data."""
    # Signature 'XYZ ' + 4 reserved bytes
    header = b'XYZ \x00\x00\x00\x00'
    # Encode X, Y, Z as s15Fixed16Number
    def to_fixed(v):
        return int(v * 65536)
    
    data = struct.pack('>iii', to_fixed(xyz[0]), to_fixed(xyz[1]), to_fixed(xyz[2]))
    return header + data


def _create_text_type(text):
    """Creates a textType tag data."""
    # Signature 'text' + 4 reserved
    header = b'text\x00\x00\x00\x00'
    return header + text.encode('ascii', 'ignore') + b'\x00'


def _create_text_description_type(text):
    """Creates a multiLocalizedUnicodeType (or simple desc type) for description."""
    # Using 'desc' type (v2) for simplicity
    # Signature 'desc' + 4 reserved
    header = b'desc\x00\x00\x00\x00'
    ascii_len = len(text) + 1
    ascii_data = struct.pack('>I', ascii_len) + text.encode('ascii', 'ignore') + b'\x00'
    # Unicode and ScriptCode parts can be empty/zero for basic v2
    rest = b'\x00' * (4 + 2 + 67) # Minimal padding to satisfy struct
    return header + ascii_data + rest


def _create_curve_type(gamma):
    """Creates a curveType tag data."""
    # Signature 'curv' + 4 reserved
    header = b'curv\x00\x00\x00\x00'
    # Count=1 means single gamma value (u8Fixed8)
    count = 1
    gamma_val = int(gamma * 256)
    return header + struct.pack('>IH', count, gamma_val)
